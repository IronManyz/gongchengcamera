/**
 * ç½‘ç»œé”™è¯¯å¤„ç†ç»„ä»¶
 * ä¸“é—¨å¤„ç†ç½‘ç»œç›¸å…³çš„é”™è¯¯å’ŒçŠ¶æ€
 */

import { ThemeManager } from '../../theme/ThemeManager'

export interface NetworkErrorConfig {
  error?: Error
  onRetry?: () => void
  onSettings?: () => void
  showDetails?: boolean
  customMessage?: string
}

export enum NetworkErrorType {
  NO_CONNECTION = 'NO_CONNECTION',
  TIMEOUT = 'TIMEOUT',
  SERVER_ERROR = 'SERVER_ERROR',
  CLIENT_ERROR = 'CLIENT_ERROR',
  UNKNOWN = 'UNKNOWN'
}

export interface NetworkErrorInfo {
  type: NetworkErrorType
  message: string
  details?: string
  canRetry: boolean
  suggestedAction?: string
}

@ComponentV2
export struct NetworkError {
  @Param config?: NetworkErrorConfig = {}
  @State private errorInfo?: NetworkErrorInfo

  aboutToAppear() {
    this.analyzeError()
  }

  /**
   * åˆ†æé”™è¯¯ç±»å‹
   */
  private analyzeError(): void {
    const error = this.config?.error
    if (!error) {
      this.errorInfo = {
        type: NetworkErrorType.UNKNOWN,
        message: this.config?.customMessage || 'ç½‘ç»œè¯·æ±‚å¤±è´¥',
        canRetry: true
      }
      return
    }

    // é”™è¯¯ç±»å‹åˆ¤æ–­
    let errorType = NetworkErrorType.UNKNOWN
    let message = this.config?.customMessage || 'ç½‘ç»œè¯·æ±‚å¤±è´¥'
    let details = ''
    let canRetry = true
    let suggestedAction = ''

    const errorMessage = error.message.toLowerCase()

    if (errorMessage.includes('network') || errorMessage.includes('connection')) {
      errorType = NetworkErrorType.NO_CONNECTION
      message = 'ç½‘ç»œè¿æ¥å¤±è´¥'
      details = 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•'
      suggestedAction = 'æ£€æŸ¥ç½‘ç»œè®¾ç½®'
    } else if (errorMessage.includes('timeout')) {
      errorType = NetworkErrorType.TIMEOUT
      message = 'è¯·æ±‚è¶…æ—¶'
      details = 'ç½‘ç»œå“åº”æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åé‡è¯•'
      canRetry = true
    } else if (errorMessage.includes('server') || errorMessage.includes('500')) {
      errorType = NetworkErrorType.SERVER_ERROR
      message = 'æœåŠ¡å™¨é”™è¯¯'
      details = 'æœåŠ¡å™¨æš‚æ—¶æ— æ³•å“åº”ï¼Œè¯·ç¨åé‡è¯•'
      canRetry = true
    } else if (errorMessage.includes('401') || errorMessage.includes('403')) {
      errorType = NetworkErrorType.CLIENT_ERROR
      message = 'è®¤è¯å¤±è´¥'
      details = 'è¯·æ£€æŸ¥ç™»å½•çŠ¶æ€æˆ–æƒé™'
      canRetry = false
      suggestedAction = 'é‡æ–°ç™»å½•'
    } else if (errorMessage.includes('404')) {
      errorType = NetworkErrorType.CLIENT_ERROR
      message = 'èµ„æºæœªæ‰¾åˆ°'
      details = 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨'
      canRetry = false
    }

    this.errorInfo = {
      type: errorType,
      message,
      details,
      canRetry,
      suggestedAction
    }
  }

  /**
   * è·å–é”™è¯¯å›¾æ ‡
   */
  private getErrorIcon(): string {
    switch (this.errorInfo?.type) {
      case NetworkErrorType.NO_CONNECTION:
        return 'ğŸ“¶'
      case NetworkErrorType.TIMEOUT:
        return 'â±ï¸'
      case NetworkErrorType.SERVER_ERROR:
        return 'ğŸ–¥ï¸'
      case NetworkErrorType.CLIENT_ERROR:
        return 'ğŸ”’'
      default:
        return 'â“'
    }
  }

  /**
   * è·å–é”™è¯¯é¢œè‰²
   */
  private getErrorColor(): string {
    switch (this.errorInfo?.type) {
      case NetworkErrorType.NO_CONNECTION:
        return '#FF9500'
      case NetworkErrorType.TIMEOUT:
        return '#FF9500'
      case NetworkErrorType.SERVER_ERROR:
        return '#FF3B30'
      case NetworkErrorType.CLIENT_ERROR:
        return '#007AFF'
      default:
        return '#666666'
    }
  }

  /**
   * è·å–ä¸»è¦é”™è¯¯ä¿¡æ¯
   */
  @Builder
  private ErrorIconSection() {
    Column() {
      Text(this.getErrorIcon())
        .fontSize(48)
        .fontColor(this.getErrorColor())
        .textAlign(TextAlign.Center)
        .margin({ bottom: 12 })

      Text(this.errorInfo?.message || 'ç½‘ç»œé”™è¯¯')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor('#333333')
        .textAlign(TextAlign.Center)

      if (this.config?.showDetails && this.errorInfo?.details) {
        Text(this.errorInfo.details)
          .fontSize(14)
          .fontColor('#666666')
          .textAlign(TextAlign.Center)
          .maxLines(3)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
          .margin({ top: 8 })
      }
    }
    .alignItems(HorizontalAlign.Center)
  }

  /**
   * æ“ä½œæŒ‰é’®åŒºåŸŸ
   */
  @Builder
  private ActionButtons() {
    Column({ space: 12 }) {
      // é‡è¯•æŒ‰é’®
      if (this.errorInfo?.canRetry && this.config?.onRetry) {
        Button() {
          Row({ space: 8 }) {
            Text('ğŸ”„')
              .fontSize(16)
            Text('é‡è¯•')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
          }
        }
        .height(44)
        .padding({ left: 24, right: 24 })
        .backgroundColor(ThemeManager.getCurrentPrimaryColor())
        .borderRadius(22)
        .fontColor('#FFFFFF')
        .onClick(() => this.config.onRetry?.())
      }

      // å»ºè®®æ“ä½œæŒ‰é’®
      if (this.errorInfo?.suggestedAction && this.config?.onSettings) {
        Button(this.errorInfo.suggestedAction)
          .fontSize(14)
          .fontColor(ThemeManager.getCurrentPrimaryColor())
          .backgroundColor(Color.Transparent)
          .border({ width: 1, color: ThemeManager.getCurrentPrimaryColor() })
          .borderRadius(22)
          .padding({ left: 20, right: 20 })
          .onClick(() => this.config.onSettings?.())
      }

      // è¯¦ç»†ä¿¡æ¯åˆ‡æ¢
      if (this.config?.showDetails !== undefined) {
        Button() {
          Text(this.config.showDetails ? 'éšè—è¯¦æƒ…' : 'æ˜¾ç¤ºè¯¦æƒ…')
            .fontSize(14)
            .fontColor('#999999')
        }
        .height(32)
        .backgroundColor(Color.Transparent)
        .onClick(() => {
          // è¿™é‡Œå¯ä»¥åˆ‡æ¢è¯¦æƒ…æ˜¾ç¤ºçŠ¶æ€
        })
      }
    }
    .width('100%')
    .alignItems(HorizontalAlign.Center)
  }

  build() {
    Column({ space: 24 }) {
      this.ErrorIconSection()
      this.ActionButtons()
    }
    .width('100%')
    .padding(32)
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .backgroundColor('#FFFFFF')
    .borderRadius(12)
    .shadow({
      radius: 8,
      color: '#00000015',
      offsetX: 0,
      offsetY: 4
    })
    .margin(16)
  }
}