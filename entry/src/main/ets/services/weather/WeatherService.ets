/**
 * å¤©æ°”æœåŠ¡ç±»
 * æä¾›å¤©æ°”ä¿¡æ¯è·å–ã€ç¼“å­˜å’Œæ°´å°é›†æˆåŠŸèƒ½
 */

import { Logger } from '../../utils/Logger'

/**
 * å¤©æ°”çŠ¶æ€æšä¸¾
 */
export enum WeatherState {
  DISABLED = 'disabled',
  INITIALIZING = 'initializing',
  LOADING = 'loading',
  AVAILABLE = 'available',
  ERROR = 'error'
}

/**
 * å¤©æ°”çŠ¶å†µæšä¸¾
 */
export enum WeatherCondition {
  CLEAR = 'clear',
  CLOUDY = 'cloudy',
  OVERCAST = 'overcast',
  LIGHT_RAIN = 'light_rain',
  MODERATE_RAIN = 'moderate_rain',
  HEAVY_RAIN = 'heavy_rain',
  THUNDERSTORM = 'thunderstorm',
  LIGHT_SNOW = 'light_snow',
  MODERATE_SNOW = 'moderate_snow',
  HEAVY_SNOW = 'heavy_snow',
  FOG = 'fog',
  MIST = 'mist',
  UNKNOWN = 'unknown'
}

/**
 * é£å‘æšä¸¾
 */
export enum WindDirection {
  N = 'N',
  NE = 'NE',
  E = 'E',
  SE = 'SE',
  S = 'S',
  SW = 'SW',
  W = 'W',
  NW = 'NW',
  VARIABLE = 'VARIABLE'
}

/**
 * å¤©æ°”æ•°æ®æ¥å£
 */
export interface WeatherData {
  location: {
    latitude: number
    longitude: number
    city?: string
    district?: string
  }
  current: {
    temperature: number // æ‘„æ°åº¦
    humidity: number // ç™¾åˆ†æ¯”
    pressure: number // hPa
    visibility: number // km
    uvIndex: number
    condition: WeatherCondition
    description: string
    icon: string // å¤©æ°”å›¾æ ‡ä»£ç 
  }
  wind: {
    speed: number // km/h
    direction: WindDirection
    directionDegree: number // åº¦æ•°
    gust?: number // é˜µé£é€Ÿåº¦
  }
  timestamp: Date
  source: string // æ•°æ®æ¥æº
}

/**
 * å¤©æ°”é¢„æŠ¥æ¥å£
 */
export interface WeatherForecast {
  date: Date
  maxTemp: number
  minTemp: number
  condition: WeatherCondition
  description: string
  humidity: number
  windSpeed: number
  precipitationProbability: number // é™æ°´æ¦‚ç‡ï¼Œç™¾åˆ†æ¯”
}

/**
 * å¤©æ°”é…ç½®æ¥å£
 */
export interface WeatherConfig {
  updateInterval: number // æ›´æ–°é—´éš”ï¼Œæ¯«ç§’
  cacheTimeout: number // ç¼“å­˜è¶…æ—¶æ—¶é—´ï¼Œæ¯«ç§’
  enableForecast: boolean
  enableAutoUpdate: boolean
  temperatureUnit: 'celsius' | 'fahrenheit'
  language: 'zh' | 'en'
}

/**
 * å¤©æ°”ç›‘å¬å™¨æ¥å£
 */
export interface WeatherListeners {
  onWeatherChanged?: (weather: WeatherData) => void
  onWeatherError?: (error: Error) => void
  onWeatherUpdate?: (weather: WeatherData) => void
}

/**
 * å¤©æ°”ç»“æœæ¥å£
 */
export interface WeatherResult {
  success: boolean
  weather?: WeatherData
  error?: Error
  fetchTime: number
}

/**
 * å¤©æ°”æœåŠ¡ç±»
 */
export class WeatherService {
  private static instance: WeatherService | null = null
  private logger = new Logger('WeatherService')

  // çŠ¶æ€ç®¡ç†
  private currentState: WeatherState = WeatherState.DISABLED
  private currentWeather: WeatherData | null = null

  // é…ç½®
  private config: WeatherConfig = {
    updateInterval: 600000, // 10åˆ†é’Ÿ
    cacheTimeout: 1800000, // 30åˆ†é’Ÿ
    enableForecast: false,
    enableAutoUpdate: true,
    temperatureUnit: 'celsius',
    language: 'zh'
  }

  // ç¼“å­˜ç›¸å…³
  private weatherCache: Map<string, { data: WeatherData; timestamp: number }> = new Map()

  // æ›´æ–°å®šæ—¶å™¨
  private updateTimer: number = -1

  // ç›‘å¬å™¨
  private listeners: WeatherListeners = {}

  // æ¨¡æ‹Ÿå¤©æ°”æ•°æ®ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
  private mockWeatherData: Partial<WeatherData> = {
    current: {
      temperature: 22,
      humidity: 65,
      pressure: 1013,
      visibility: 10,
      uvIndex: 5,
      condition: WeatherCondition.CLOUDY,
      description: 'å¤šäº‘',
      icon: 'cloudy'
    },
    wind: {
      speed: 12,
      direction: WindDirection.SE,
      directionDegree: 135
    }
  }

  private constructor() {
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): WeatherService {
    if (!WeatherService.instance) {
      WeatherService.instance = new WeatherService()
    }
    return WeatherService.instance
  }

  /**
   * åˆå§‹åŒ–å¤©æ°”æœåŠ¡
   */
  async initialize(): Promise<void> {
    this.logger.info('Initializing WeatherService...')

    try {
      this.setState(WeatherState.INITIALIZING)

      // åˆå§‹åŒ–æœåŠ¡é…ç½®
      this.loadConfiguration()

      // å¦‚æœå¯ç”¨è‡ªåŠ¨æ›´æ–°ï¼Œå¯åŠ¨å®šæ—¶å™¨
      if (this.config.enableAutoUpdate) {
        this.startAutoUpdate()
      }

      this.setState(WeatherState.AVAILABLE)
      this.logger.info('WeatherService initialized successfully')

    } catch (error) {
      this.setState(WeatherState.ERROR)
      this.logger.error('Failed to initialize WeatherService', error)
      throw error
    }
  }

  /**
   * åŠ è½½é…ç½®
   */
  private loadConfiguration(): void {
    // è¿™é‡Œå¯ä»¥ä»æŒä¹…åŒ–å­˜å‚¨åŠ è½½é…ç½®
    // ç›®å‰ä½¿ç”¨é»˜è®¤é…ç½®
    this.logger.info('Weather configuration loaded', this.config)
  }

  /**
   * è·å–å½“å‰å¤©æ°”
   */
  async getCurrentWeather(latitude: number, longitude: number): Promise<WeatherResult> {
    this.logger.info('Getting current weather...', { latitude, longitude })

    const startTime = Date.now()

    try {
      this.setState(WeatherState.LOADING)

      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = `${latitude.toFixed(4)},${longitude.toFixed(4)}`
      const cached = this.weatherCache.get(cacheKey)

      if (cached && (Date.now() - cached.timestamp) < this.config.cacheTimeout) {
        this.currentWeather = cached.data
        this.setState(WeatherState.AVAILABLE)
        this.notifyWeatherChanged(cached.data)

        const result: WeatherResult = {
          success: true,
          weather: cached.data,
          fetchTime: Date.now() - startTime
        }

        this.logger.info('Weather retrieved from cache', { fetchTime: result.fetchTime })
        return result
      }

      // è·å–æ–°æ•°æ®
      const weather = await this.fetchWeatherData(latitude, longitude)

      // ç¼“å­˜æ•°æ®
      this.weatherCache.set(cacheKey, {
        data: weather,
        timestamp: Date.now()
      })

      this.currentWeather = weather
      this.setState(WeatherState.AVAILABLE)
      this.notifyWeatherChanged(weather)

      const result: WeatherResult = {
        success: true,
        weather: weather,
        fetchTime: Date.now() - startTime
      }

      this.logger.info('Weather retrieved successfully', {
        temperature: weather.current.temperature,
        condition: weather.current.condition,
        fetchTime: result.fetchTime
      })

      return result

    } catch (error) {
      this.setState(WeatherState.ERROR)
      const weatherError = error instanceof Error ? error : new Error(String(error))
      this.logger.error('Failed to get weather', error)
      this.notifyWeatherError(weatherError)

      const result: WeatherResult = {
        success: false,
        error: weatherError,
        fetchTime: Date.now() - startTime
      }

      return result
    }
  }

  /**
   * è·å–å¤©æ°”æ•°æ®
   */
  private async fetchWeatherData(latitude: number, longitude: number): Promise<WeatherData> {
    // è¿™é‡Œåº”è¯¥è°ƒç”¨çœŸå®çš„å¤©æ°”API
    // ç”±äºHarmonyOSé™åˆ¶ï¼Œè¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®

    this.logger.info('Fetching weather data from API...', { latitude, longitude })

    // æ¨¡æ‹ŸAPIå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1000))

    // ç”Ÿæˆæ¨¡æ‹Ÿå¤©æ°”æ•°æ®
    const weatherData: WeatherData = {
      location: {
        latitude: latitude,
        longitude: longitude,
        city: 'åŒ—äº¬å¸‚',
        district: 'æµ·æ·€åŒº'
      },
      current: {
        temperature: this.mockWeatherData.current?.temperature || 22,
        humidity: this.mockWeatherData.current?.humidity || 65,
        pressure: this.mockWeatherData.current?.pressure || 1013,
        visibility: this.mockWeatherData.current?.visibility || 10,
        uvIndex: this.mockWeatherData.current?.uvIndex || 5,
        condition: this.mockWeatherData.current?.condition || WeatherCondition.CLOUDY,
        description: this.mockWeatherData.current?.description || 'å¤šäº‘',
        icon: this.mockWeatherData.current?.icon || 'cloudy'
      },
      wind: {
        speed: this.mockWeatherData.wind?.speed || 12,
        direction: this.mockWeatherData.wind?.direction || WindDirection.SE,
        directionDegree: this.mockWeatherData.wind?.directionDegree || 135,
        gust: this.mockWeatherData.wind?.gust || 18
      },
      timestamp: new Date(),
      source: 'WeatherService (Mock)'
    }

    return weatherData
  }

  /**
   * è·å–å¤©æ°”é¢„æŠ¥
   */
  async getWeatherForecast(latitude: number, longitude: number, days: number = 3): Promise<WeatherForecast[]> {
    this.logger.info('Getting weather forecast...', { latitude, longitude, days })

    try {
      if (!this.config.enableForecast) {
        throw new Error('Weather forecast is disabled')
      }

      // æ¨¡æ‹Ÿå¤©æ°”é¢„æŠ¥æ•°æ®
      const forecasts: WeatherForecast[] = []
      const baseDate = new Date()

      for (let i = 0; i < days; i++) {
        const forecastDate = new Date(baseDate)
        forecastDate.setDate(baseDate.getDate() + i + 1)

        const condition = this.getRandomWeatherCondition()
        forecasts.push({
          date: forecastDate,
          maxTemp: 25 + Math.floor(Math.random() * 10),
          minTemp: 15 + Math.floor(Math.random() * 10),
          condition: condition,
          description: this.getWeatherDescription(condition),
          humidity: 50 + Math.floor(Math.random() * 40),
          windSpeed: 5 + Math.floor(Math.random() * 20),
          precipitationProbability: Math.floor(Math.random() * 100)
        })
      }

      this.logger.info('Weather forecast retrieved successfully', { days })
      return forecasts

    } catch (error) {
      this.logger.error('Failed to get weather forecast', error)
      throw error
    }
  }

  /**
   * å¼€å§‹è‡ªåŠ¨æ›´æ–°
   */
  private startAutoUpdate(): void {
    if (this.updateTimer >= 0) {
      clearInterval(this.updateTimer)
    }

    this.updateTimer = setInterval(async () => {
      if (this.currentWeather) {
        try {
          await this.getCurrentWeather(
            this.currentWeather.location.latitude,
            this.currentWeather.location.longitude
          )
        } catch (error) {
          this.logger.error('Auto update failed', error)
        }
      }
    }, this.config.updateInterval)

    this.logger.info('Auto update started', { interval: this.config.updateInterval })
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ›´æ–°
   */
  stopAutoUpdate(): void {
    if (this.updateTimer >= 0) {
      clearInterval(this.updateTimer)
      this.updateTimer = -1
      this.logger.info('Auto update stopped')
    }
  }

  /**
   * é…ç½®å¤©æ°”æœåŠ¡
   */
  configure(config: Partial<WeatherConfig>): void {
    this.config = { ...this.config, ...config }
    this.logger.info('Weather configuration updated', this.config)

    // å¦‚æœè‡ªåŠ¨æ›´æ–°é…ç½®å‘ç”Ÿå˜åŒ–ï¼Œé‡æ–°å¯åŠ¨å®šæ—¶å™¨
    if (this.config.enableAutoUpdate && this.currentState === WeatherState.AVAILABLE) {
      this.startAutoUpdate()
    } else if (!this.config.enableAutoUpdate) {
      this.stopAutoUpdate()
    }
  }

  /**
   * è®¾ç½®ç›‘å¬å™¨
   */
  setListeners(listeners: WeatherListeners): void {
    this.listeners = { ...this.listeners, ...listeners }
  }

  /**
   * æ¸…é™¤ç¼“å­˜
   */
  clearCache(): void {
    this.weatherCache.clear()
    this.logger.info('Weather cache cleared')
  }

  /**
   * è®¾ç½®çŠ¶æ€
   */
  private setState(state: WeatherState): void {
    const oldState = this.currentState
    this.currentState = state
    this.logger.info('Weather state changed', { from: oldState, to: state })
  }

  /**
   * é€šçŸ¥å¤©æ°”å˜åŒ–
   */
  private notifyWeatherChanged(weather: WeatherData): void {
    if (this.listeners.onWeatherChanged) {
      try {
        this.listeners.onWeatherChanged(weather)
      } catch (error) {
        this.logger.error('Error in weather changed callback', error)
      }
    }

    if (this.listeners.onWeatherUpdate) {
      try {
        this.listeners.onWeatherUpdate(weather)
      } catch (error) {
        this.logger.error('Error in weather update callback', error)
      }
    }
  }

  /**
   * é€šçŸ¥å¤©æ°”é”™è¯¯
   */
  private notifyWeatherError(error: Error): void {
    if (this.listeners.onWeatherError) {
      try {
        this.listeners.onWeatherError(error)
      } catch (callbackError) {
        this.logger.error('Error in weather error callback', callbackError)
      }
    }
  }

  /**
   * è·å–éšæœºå¤©æ°”çŠ¶å†µ
   */
  private getRandomWeatherCondition(): WeatherCondition {
    const conditions = Object.values(WeatherCondition)
    return conditions[Math.floor(Math.random() * conditions.length)]
  }

  /**
   * è·å–å¤©æ°”æè¿°
   */
  private getWeatherDescription(condition: WeatherCondition): string {
    const descriptions: Record<WeatherCondition, string> = {
      [WeatherCondition.CLEAR]: 'æ™´æœ—',
      [WeatherCondition.CLOUDY]: 'å¤šäº‘',
      [WeatherCondition.OVERCAST]: 'é˜´å¤©',
      [WeatherCondition.LIGHT_RAIN]: 'å°é›¨',
      [WeatherCondition.MODERATE_RAIN]: 'ä¸­é›¨',
      [WeatherCondition.HEAVY_RAIN]: 'å¤§é›¨',
      [WeatherCondition.THUNDERSTORM]: 'é›·é˜µé›¨',
      [WeatherCondition.LIGHT_SNOW]: 'å°é›ª',
      [WeatherCondition.MODERATE_SNOW]: 'ä¸­é›ª',
      [WeatherCondition.HEAVY_SNOW]: 'å¤§é›ª',
      [WeatherCondition.FOG]: 'é›¾',
      [WeatherCondition.MIST]: 'è–„é›¾',
      [WeatherCondition.UNKNOWN]: 'æœªçŸ¥'
    }

    return descriptions[condition] || 'æœªçŸ¥'
  }

  /**
   * è·å–å½“å‰å¤©æ°”æ•°æ®
   */
  getCurrentWeatherData(): WeatherData | null {
    return this.currentWeather ? { ...this.currentWeather } : null
  }

  /**
   * è·å–å¤©æ°”çŠ¶æ€
   */
  getState(): WeatherState {
    return this.currentState
  }

  /**
   * è·å–å¤©æ°”å›¾æ ‡
   */
  getWeatherIcon(condition: WeatherCondition): string {
    const icons: Record<WeatherCondition, string> = {
      [WeatherCondition.CLEAR]: 'â˜€ï¸',
      [WeatherCondition.CLOUDY]: 'â›…',
      [WeatherCondition.OVERCAST]: 'â˜ï¸',
      [WeatherCondition.LIGHT_RAIN]: 'ğŸŒ¦ï¸',
      [WeatherCondition.MODERATE_RAIN]: 'ğŸŒ§ï¸',
      [WeatherCondition.HEAVY_RAIN]: 'â›ˆï¸',
      [WeatherCondition.THUNDERSTORM]: 'â›ˆï¸',
      [WeatherCondition.LIGHT_SNOW]: 'ğŸŒ¨ï¸',
      [WeatherCondition.MODERATE_SNOW]: 'â„ï¸',
      [WeatherCondition.HEAVY_SNOW]: 'ğŸŒ¨ï¸',
      [WeatherCondition.FOG]: 'ğŸŒ«ï¸',
      [WeatherCondition.MIST]: 'ğŸŒ«ï¸',
      [WeatherCondition.UNKNOWN]: 'â“'
    }

    return icons[condition] || 'â“'
  }

  /**
   * æ ¼å¼åŒ–æ¸©åº¦
   */
  formatTemperature(temperature: number): string {
    if (this.config.temperatureUnit === 'fahrenheit') {
      const fahrenheit = (temperature * 9/5) + 32
      return `${Math.round(fahrenheit)}Â°F`
    }
    return `${Math.round(temperature)}Â°C`
  }

  /**
   * æ ¼å¼åŒ–é£å‘
   */
  formatWindDirection(direction: WindDirection): string {
    const directions: Record<WindDirection, string> = {
      [WindDirection.N]: 'åŒ—é£',
      [WindDirection.NE]: 'ä¸œåŒ—é£',
      [WindDirection.E]: 'ä¸œé£',
      [WindDirection.SE]: 'ä¸œå—é£',
      [WindDirection.S]: 'å—é£',
      [WindDirection.SW]: 'è¥¿å—é£',
      [WindDirection.W]: 'è¥¿é£',
      [WindDirection.NW]: 'è¥¿åŒ—é£',
      [WindDirection.VARIABLE]: 'é£å‘ä¸å®š'
    }

    return directions[direction] || 'é£å‘æœªçŸ¥'
  }

  /**
   * è·å–æœåŠ¡ç»Ÿè®¡ä¿¡æ¯
   */
  getServiceStats(): {
    state: WeatherState
    cacheSize: number
    autoUpdateEnabled: boolean
    config: WeatherConfig
  } {
    return {
      state: this.currentState,
      cacheSize: this.weatherCache.size,
      autoUpdateEnabled: this.config.enableAutoUpdate,
      config: { ...this.config }
    }
  }

  /**
   * é‡Šæ”¾èµ„æº
   */
  async release(): Promise<void> {
    this.logger.info('Releasing WeatherService resources...')

    try {
      // åœæ­¢è‡ªåŠ¨æ›´æ–°
      this.stopAutoUpdate()

      // æ¸…é™¤ç¼“å­˜
      this.clearCache()

      // æ¸…ç†çŠ¶æ€
      this.currentWeather = null
      this.setState(WeatherState.DISABLED)

      this.logger.info('WeatherService resources released successfully')
    } catch (error) {
      this.logger.error('Failed to release WeatherService resources', error)
    }
  }
}