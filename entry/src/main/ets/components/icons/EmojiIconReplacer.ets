/**
 * Emoji å›¾æ ‡æ‰¹é‡æ›¿æ¢å·¥å…·
 * æä¾›ä¾¿æ·çš„ emoji åˆ°å›¾æ ‡æ›¿æ¢åŠŸèƒ½
 */

import { EngineeringIcon, Icons } from './EngineeringIcon'
import { EMOJI_TO_ICON_MAP, getIconMapping } from './EmojiToIconMapper'

/**
 * Emoji å›¾æ ‡æ›¿æ¢å™¨
 * ç”¨äºæ‰¹é‡æ›¿æ¢é¡¹ç›®ä¸­çš„ emoji å›¾æ ‡
 */
export class EmojiIconReplacer {
  private static instance: EmojiIconReplacer

  static getInstance(): EmojiIconReplacer {
    if (!EmojiIconReplacer.instance) {
      EmojiIconReplacer.instance = new EmojiIconReplacer()
    }
    return EmojiIconReplacer.instance
  }

  /**
   * æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å« emoji
   */
  hasEmoji(text: string): boolean {
    const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u
    return emojiRegex.test(text)
  }

  /**
   * è·å–æ–‡æœ¬ä¸­æ‰€æœ‰çš„ emoji
   */
  extractEmojis(text: string): string[] {
    const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu
    const matches = text.match(emojiRegex)
    return matches ? [...new Set(matches)] : []
  }

  /**
   * å°† emoji è½¬æ¢ä¸ºå›¾æ ‡ç»„ä»¶
   */
  emojiToIconComponent(
    emoji: string,
    props?: { size?: number | string, color?: string, strokeWidth?: number }
  ): EngineeringIcon | null {
    const mapping = getIconMapping(emoji)
    if (!mapping) return null

    const iconName = mapping.iconName as keyof typeof Icons
    const color = props?.color || mapping.defaultColor || '#1890FF'
    const size = props?.size || 24
    const strokeWidth = props?.strokeWidth || 2

    if (Icons[iconName]) {
      return Icons[iconName]({ size, color, strokeWidth })
    }

    return null
  }

  /**
   * åˆ›å»ºå›¾æ ‡æ„å»ºå™¨
   */
  createIconBuilder(emoji: string, defaultProps?: { size?: number | string, color?: string, strokeWidth?: number }) {
    return (props?: { size?: number | string, color?: string, strokeWidth?: number }) => {
      const finalProps = { ...defaultProps, ...props }
      return this.emojiToIconComponent(emoji, finalProps)
    }
  }

  /**
   * æ‰¹é‡æ›¿æ¢ç»„ä»¶ä¸­çš„ emoji
   */
  replaceEmojisInComponent<T extends Record<string, any>>(
    component: T,
    emojiFields: (keyof T)[],
    iconProps?: { size?: number | string, color?: string, strokeWidth?: number }
  ): Partial<T> {
    const result: Partial<T> = {}

    emojiFields.forEach(field => {
      const value = component[field]
      if (typeof value === 'string' && this.hasEmoji(value)) {
        const iconComponent = this.emojiToIconComponent(value, iconProps)
        if (iconComponent) {
          result[field] = iconComponent as any
        }
      }
    })

    return result
  }

  /**
   * è·å–å¸¸ç”¨å›¾æ ‡çš„å¿«æ·åˆ›å»ºå™¨
   */
  static get IconCreators() {
    const replacer = EmojiIconReplacer.getInstance()

    return {
      // å¯¼èˆªå›¾æ ‡
      building: (props?: any) => Icons.building(props),
      photo: (props?: any) => Icons.photo(props),
      settings: (props?: any) => Icons.settings(props),
      home: (props?: any) => Icons.home(props),

      // æ“ä½œå›¾æ ‡
      camera: (props?: any) => Icons.camera(props),
      mapPin: (props?: any) => Icons.mapPin(props),
      upload: (props?: any) => Icons.upload(props),
      refresh: (props?: any) => Icons.refresh(props),
      edit: (props?: any) => Icons.edit(props),
      search: (props?: any) => Icons.search(props),

      // çŠ¶æ€å›¾æ ‡
      check: (props?: any) => Icons.check(props),
      x: (props?: any) => Icons.x(props),
      alertTriangle: (props?: any) => Icons.alertTriangle(props),
      infoCircle: (props?: any) => Icons.infoCircle(props),

      // å¤©æ°”å›¾æ ‡
      sun: (props?: any) => Icons.sun(props),
      cloud: (props?: any) => Icons.cloud(props),
      cloudRain: (props?: any) => Icons.cloudRain(props),
      snowflake: (props?: any) => Icons.snowflake(props),
      mist: (props?: any) => Icons.mist(props),

      // å…¶ä»–å›¾æ ‡
      chartBar: (props?: any) => Icons.chartBar(props),
      palette: (props?: any) => Icons.palette(props),
      world: (props?: any) => Icons.world(props),
      lock: (props?: any) => Icons.lock(props),

      // Emoji åˆ°å›¾æ ‡çš„å¿«é€Ÿè½¬æ¢
      fromEmoji: (emoji: string, props?: any) => replacer.emojiToIconComponent(emoji, props)
    }
  }

  /**
   * è·å–æ‰€æœ‰æ”¯æŒçš„ emoji æ˜ å°„
   */
  getAllSupportedEmojis(): Record<string, { iconName: string, description: string }> {
    const result: Record<string, { iconName: string, description: string }> = {}

    Object.entries(EMOJI_TO_ICON_MAP).forEach(([emoji, mapping]) => {
      result[emoji] = {
        iconName: mapping.iconName,
        description: mapping.description || ''
      }
    })

    return result
  }

  /**
   * æ ¹æ®ç”¨é€”åˆ†ç±»è·å–å›¾æ ‡
   */
  getIconsByPurpose(): Record<string, Array<{ emoji: string, iconName: string, description: string }>> {
    const categories: Record<string, Array<{ emoji: string, iconName: string, description: string }>> = {
      navigation: [],
      actions: [],
      status: [],
      weather: [],
      ui: []
    }

    Object.entries(EMOJI_TO_ICON_MAP).forEach(([emoji, mapping]) => {
      const item = {
        emoji,
        iconName: mapping.iconName,
        description: mapping.description || ''
      }

      if (['ğŸ—ï¸', 'ğŸ“±', 'âš™ï¸', 'ğŸ ', 'ğŸ“'].includes(emoji)) {
        categories.navigation.push(item)
      } else if (['ğŸ“¸', 'ğŸ“¤', 'ğŸ”„', 'âœï¸', 'âœ“', 'ğŸ¨', 'ğŸ–¼ï¸', 'ğŸ”', 'ğŸ“Š', 'ğŸ“'].includes(emoji)) {
        categories.actions.push(item)
      } else if (['âœ…', 'âŒ', 'âš ï¸', '!', 'âš ', 'â„¹', 'â„¹ï¸'].includes(emoji)) {
        categories.status.push(item)
      } else if (['â˜€ï¸', 'â˜ï¸', 'ğŸŒ¦ï¸', 'ğŸŒ§ï¸', 'â›ˆï¸', 'ğŸŒ¨ï¸', 'â„ï¸', 'ğŸŒ«ï¸', 'ğŸŒ¤ï¸'].includes(emoji)) {
        categories.weather.push(item)
      } else {
        categories.ui.push(item)
      }
    })

    return categories
  }
}

/**
 * å…¨å±€é»˜è®¤å›¾æ ‡æ›¿æ¢å™¨å®ä¾‹
 */
export const iconReplacer = EmojiIconReplacer.getInstance()

/**
 * ä¾¿æ·å‡½æ•°ï¼šå¿«é€Ÿåˆ›å»ºå›¾æ ‡
 */
export function createIcon(emojiOrIconName: string, props?: { size?: number | string, color?: string, strokeWidth?: number }) {
  return iconReplacer.emojiToIconComponent(emojiOrIconName, props)
}

/**
 * ä¾¿æ·å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦æ”¯æŒæŸä¸ª emoji
 */
export function isEmojiSupported(emoji: string): boolean {
  return emoji in EMOJI_TO_ICON_MAP
}

/**
 * ä¾¿æ·å‡½æ•°ï¼šè·å–æ¨èçš„å›¾æ ‡é¢œè‰²
 */
export function getRecommendedIconColor(emoji: string): string {
  const mapping = getIconMapping(emoji)
  return mapping?.defaultColor || '#1890FF'
}